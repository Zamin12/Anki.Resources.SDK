// Copyright © 2020 Randall Maas. All rights reserved.
// See LICENSE file in the project root for full license information.  
// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace Anki.VectorAnim
{

using global::System;
using global::FlatBuffers;

/// <summary>
/// The RobotAudio structure is used to interact with the audio engine.
/// </summary>
public struct RobotAudio : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static RobotAudio GetRootAsRobotAudio(ByteBuffer _bb) { return GetRootAsRobotAudio(_bb, new RobotAudio()); }
  public static RobotAudio GetRootAsRobotAudio(ByteBuffer _bb, RobotAudio obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
  public RobotAudio __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// <summary>
  /// The time the audio events should be sent, and the parameters should be set.
  /// </summary>
  public uint TriggerTimeMs { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  /// <summary>
  /// The set of possible audio events to send.
  /// </summary>
  public AudioEventGroup? EventGroups(int j) { int o = __p.__offset(6); return o != 0 ? (AudioEventGroup?)(new AudioEventGroup()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int EventGroupsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// <summary>
  /// The settings to put different audio states into.
  /// </summary>
  public AudioState? States(int j) { int o = __p.__offset(8); return o != 0 ? (AudioState?)(new AudioState()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int StatesLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// <summary>
  /// The configuration of the audio context –setting the audio “switches” to
  /// use the right sounds and effects for the circumstances.
  /// </summary>
  public AudioSwitch? Switches(int j) { int o = __p.__offset(10); return o != 0 ? (AudioSwitch?)(new AudioSwitch()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int SwitchesLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// <summary>
  /// The set of changes to make to the audio playback parameters.
  /// </summary>
  public AudioParameter? Parameters(int j) { int o = __p.__offset(12); return o != 0 ? (AudioParameter?)(new AudioParameter()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int ParametersLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<RobotAudio> CreateRobotAudio(FlatBufferBuilder builder,
      uint triggerTime_ms = 0,
      VectorOffset eventGroupsOffset = default(VectorOffset),
      VectorOffset statesOffset = default(VectorOffset),
      VectorOffset switchesOffset = default(VectorOffset),
      VectorOffset parametersOffset = default(VectorOffset)) {
    builder.StartObject(5);
    RobotAudio.AddParameters(builder, parametersOffset);
    RobotAudio.AddSwitches(builder, switchesOffset);
    RobotAudio.AddStates(builder, statesOffset);
    RobotAudio.AddEventGroups(builder, eventGroupsOffset);
    RobotAudio.AddTriggerTimeMs(builder, triggerTime_ms);
    return RobotAudio.EndRobotAudio(builder);
  }

  public static void StartRobotAudio(FlatBufferBuilder builder) { builder.StartObject(5); }
  public static void AddTriggerTimeMs(FlatBufferBuilder builder, uint triggerTimeMs) { builder.AddUint(0, triggerTimeMs, 0); }
  public static void AddEventGroups(FlatBufferBuilder builder, VectorOffset eventGroupsOffset) { builder.AddOffset(1, eventGroupsOffset.Value, 0); }
  public static VectorOffset CreateEventGroupsVector(FlatBufferBuilder builder, Offset<AudioEventGroup>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateEventGroupsVectorBlock(FlatBufferBuilder builder, Offset<AudioEventGroup>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartEventGroupsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddStates(FlatBufferBuilder builder, VectorOffset statesOffset) { builder.AddOffset(2, statesOffset.Value, 0); }
  public static VectorOffset CreateStatesVector(FlatBufferBuilder builder, Offset<AudioState>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateStatesVectorBlock(FlatBufferBuilder builder, Offset<AudioState>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartStatesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSwitches(FlatBufferBuilder builder, VectorOffset switchesOffset) { builder.AddOffset(3, switchesOffset.Value, 0); }
  public static VectorOffset CreateSwitchesVector(FlatBufferBuilder builder, Offset<AudioSwitch>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSwitchesVectorBlock(FlatBufferBuilder builder, Offset<AudioSwitch>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartSwitchesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddParameters(FlatBufferBuilder builder, VectorOffset parametersOffset) { builder.AddOffset(4, parametersOffset.Value, 0); }
  public static VectorOffset CreateParametersVector(FlatBufferBuilder builder, Offset<AudioParameter>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateParametersVectorBlock(FlatBufferBuilder builder, Offset<AudioParameter>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static void StartParametersVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<RobotAudio> EndRobotAudio(FlatBufferBuilder builder) {
    int o = builder.EndObject();
    return new Offset<RobotAudio>(o);
  }
};


}
